
<!--* [第1章 MySQL体系结构和存储引擎](#1)-->
<!-- -->
<!--* [第2章 InnoDB存储引擎](#2)  -->
<!--* [第3章 文件](#3)  -->
<!--* [第4章 表](#4)  -->
<!--* [第5章 索引与算法](#5)  -->
<!--* [第6章 锁](#6)  -->
<!--* [第7章 事务](#7)  -->
<!--* [第8章 备份和恢复](#8)  -->
<!--* [第9章 性能调优](#9)  -->
<!--* [第10章 InnDB存储引擎源代码的编译和调试](#10)  -->

<!--<h4 id="1">MySQL体系结构和存储引擎</h4>-->-

#### 1.1 数据库和实例
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**<font 
color=red>数据库</font>**：物理操作系统文件或其他形式文件类型的集合。在MySQL数据库中，数据库文件可以是frm、MYD、MYI、idb结尾的文件
。当使用NDB时，数据库的文件可能不是操作系统上的文件，而是存放于内存之中的文件，但是定义仍然不变。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**<font
color=red>实例</font>**：MySQL数据库由后台进程以及一个共享内存区组成。共享内存可以被运行的后台线程所共享。数据库实例才是真正用于操作数据库文件的。  

MySQL被设计为一个单进程多线程架构的数据库，Oracle则是多进程的架构，Windows版本下与MySQL一样。

查找配置文件的目录位置 
~~~
mysql --help | grep my.cnf
~~~
如果有几个配置文件都有同一个配置参数，则以读取到的最后一个配置文件中的参数为准。Linux下，配置文件一般默认在/etc/my.cnf下。

配置文件中有个参数datadir，该参数指定了数据库所在的路径。在Linux下，默认在/usr/local/mysql/data。查看指令
~~~
mysql>show variables like  'datadir'\G;
~~~
从概念上来说，数据库是文件的集合，是依照某种数据模型组织起来并存放于二级存储器中的数据集合；数据库实例是程序，是位于用户
和操作系统之间的一层数据管理软件，用户对数据库数据的任何操作，包括数据库定义、数据查询、数据维护、数据库运行监控等都是在
数据库实例下进行的，应用程序只有通过数据库实例才能和数据库打交道。


**MySQL由以下几部分组成**
* 连接池组件
* 管理服务和工具组件
* SQL接口组件
* 查询分析器组件
* 优化器组件
* 缓冲组件
* 插件式存储引擎（基于表的，而不是数据库）
* 物理文件

#### 1.2 InnoDB存储引擎
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InnoDB存储引擎支持书屋，其设计目标主要面向在线事务处理（OLTP）的应用。其特点是行锁设计、支持外键，
并支持类似于Oracle的非锁定读，即默认读取操作不会产生锁。MySQL5.5.8后，其为默认的存储引擎。   

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InnoDB通过使用多版本并发控制(MVCC)来获得高并发，并实现了SQL标准的4种隔离级别，默认为REPEATABLE级别。
同时，使用一种被称为next-keylocking的策略来避免幻读（phantom）现象的产生。除此之外，InnoDB存储引擎还提供了插入缓冲、二次写、自适应哈希索引、
预读等高性能和高可用的功能。  

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于表中数据的存储，InnoDB存储引擎采用了聚集的方式，因此每张标的存储都是按照主键的顺序进行存放。如果没有
显式地在表定义时指定主键，InnoDB存储引擎会为每一行生成一个6字节的rowid，并以此为主键。   

##### 1.2.1 后台线程
InnoDB存储引擎是多线程的模型，因此其后台有多个不同的后台线程，负责处理不同的任务.    
1. Master Thread    
一个非常核心的后台线程，主要负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新、合并插入缓冲、UNDO页的回收等。
2. IO Thread    
使用了大量AIO（Async IO）来处理写IO请求，这样可以保证数据库的性能。而IO Thread的工作主要是负责这些IO请求的回调处理，基本可分为write、read、insert buffer
和log IO Thread。可通过innodb_read_io_threads和innodb_write_io_threads来设置read、write IO Thread的线程数量。一般读线程的ID总是小于写线程。   
3. Purge Thread     
事务被提交后，其所使用的undo log可能不再需要，因此需要Purge Thread来回收已经使用并分配的undo页。可在配置文件中设置命令来启用独立的Purge Thread
~~~
innodb_purge_threads =1
~~~     
4. Page Cleaner Thread  
Page Cleaner Thread是在InnoDB 1.2.x版本引入的，其作用是将之前版本中脏页的刷新操作都放到单独的线程中来完成。减轻元Master Thread的工作以及对用户查询线程的阻塞。进一步提高性能。

##### 1.2.2 内存
1. 缓冲池  
InnoDB存储引擎是基于磁盘存储的，并将其中的记录按照页的方式进行管理。因此可将其视为基于磁盘的数据库系统。     
缓冲池简单来说就是一块内存区域，通过内存的速度来弥补磁盘速度较慢对数据库的性能的影响。在数据库中进行读取页的操作，首先将从磁盘读取到的页放入缓冲池中，
这个过程叫做页“FIX”在缓冲池中。下一次在读取相同的页时，首先判断该页是否在缓冲池中。若在，称为该页在缓冲池中被命中，直接读取该页。否则，读取磁盘上的页。
对于数据库中页的修改操作，必须首先修改在缓冲池中的页，然后再以一定的频率刷新到磁盘中。这里需要注意的是，页从缓冲池刷新回磁盘的操作并不是在每次页发生更新时触发，而是
通过一种称为checkpoint的机制刷新回磁盘。   
可通过innodb_buffer_pool_size在配置文件中设置缓冲池的大小     

    具体来说，缓冲池中缓存的数据页类型有：索引页、数据页、undo页、插入缓冲、自适应哈希索引、InnoDB存储的锁信息、数据字典信息等。
    
    从 innodb 1.0.x版本开始，允许有多个缓冲池实例，每个页根据哈希值平均分配到不同缓冲池实例中。好处是减少数据库内部的资源竞争，增加数据库的并发处理能力，可通过参数
    innodb_buffer_pool_instances来进行设置，默认为1。
2. LRU List
通常来说，数据库中的缓冲池是通过LRU（Latest Recent Used，最近最少使用）算法来进行管理的。即最频繁使用的页在LRU的前端，而最少使用的页在LRU的尾端。当缓冲池不能存放新读取到的页时，
将首先释放LRU列表的尾端的页。     
在InnoDB的存储引擎中，LRU列表中还加入了midpoint位置，新读取到的页，虽然是最新访问的页，但并不是直接放入到LRU列表的首部，而是放入到LRU列表的midpoint位置，可通过innodb_old_block_pct来设置。     
这是因为若直接将读取到的页放入到LRU的首部，那么某些SQL操作可能会使缓冲池中的页被刷新出，从而影响缓冲池的效率。常见的这类操作作为索引或数据的扫描操作。这类操作需要访问表中的许多页，甚至是全部的页，而这些页
通常来说有仅在这次查询操作中需要，并不是活跃的热点数据。如果被放到LRU列表的首部，那么非常可能将所需要的热点数据页从LRU列表中移除，而在下一次需要读取页时，InnoDB存储引擎需要再次访问磁盘。为解决这个问题，引入
另一个参数innodb_old_blocks_time,用来表示页读取到mid位置后需要等待多久才会被假如到LRU列表的热端。     

    在LRU列表中的页被修改后，称该页为脏页，即缓冲池中的页和磁盘上的页数据产生了不一致。这时数据库会通过checkpoint机制将脏页刷新回磁盘，而Flush列表中的页即为脏页列表。需要注意的是，脏页既存在于LRU列表中，也存在于Flush列表中。
    LRU列表用来管理缓冲池中页的可用性，Flush列表用来管理将页刷新回磁盘，两者互不影响。
3. 重做日志缓冲   
InnoDB存储引擎首先将重做日志信息先放入到这个缓冲区，然后按一定频率将其刷新到重做日志文件。可通过innodb_log_buffer_size来控制，默认为8MB.    
通常情况下，8MB的重做日志缓冲池足以满足绝大部分的应用。因为重做日志在下列三种情况下会将日志缓冲中的内容刷新到外部磁盘的重做日志文件中。   
a、Master Thread每一秒将重做日志缓冲刷新到重做日志文件  
b、每个事物提交时会将重做日志缓冲刷新到重做日志文件  
c、当重做日志缓冲池剩余空间小于1/2时，重做日志缓冲刷新到重做日志文件

4. 额外的内存池   
在InnoDB存储引擎中，对内存的管理是通过一种称为内存堆的方式进行的。在对一些数据结构本身的内存进行分配时，需要从额外的内存池中进行申请，当该区域的存储不够时，会从缓冲池进行申请。因此
在申请了很大的InnoDB缓冲池时，也应考虑相应的增加这个值。

##### 1.2.3 CheckPoint技术
checkpoint技术的目的是解决以下几个问题：   
1、缩短数据库的恢复时间    
2、缓冲池不够用时，将脏页刷新到磁盘  
3、重做日志不可用时，刷新脏页 

在InnoDB存储引擎中，有两种checkpoint,分别是  
Sharp Checkpoint    
Fuzzy Checkpoint    
Sharp Checkpoint发生在数据库关闭时将所有的脏页都刷新到磁盘，这是默认的工作方式，即innodb_fast_shutdown=1


##### 1.2.4 InnoDB关键特性  
a、插入缓冲  
b、两次写   
c、自适应哈希索引   
d、异步IO  
e、刷新领接页 

1. 插入缓冲(insert buffer)  
对于非聚集索引的插入或更新操作，不是每一次直接插入到索引页中，而是先判断插入的非聚集索引是否在缓冲池中，如在，则直接插入；如不在，则先放入到一个Insert Buffer对象中，
好似欺骗。数据库这个非聚集的索引已经插到叶子节点，而实际并没有，只是存放在另一个位置。然后再以一定的频率和情况进行Insert Buffer和辅助缩影叶子节点的merge(合并)操作，
这时通常能将多个插入合并到一个操作中(因为在一个索引页中)，大大提高了性能。  
Insert Buffer的使用需要满足以下两个条件
a、索引是辅助索引   
b、索引不是唯一的   
问题：在写密集的情况下，插入缓冲池会占用过多的缓冲池内存，默认最大可以占用到1/2的缓冲池内存。这对于其他的操作可能会带来一定的影响，可通过ibuf_pool_size_pre_max_size来进行控制，为3时，表示最大只能使用1/3的缓冲池内存

2. 两次写   
double write由两部分组成，一部分是内存中的double write buffer,大小为2MB，另一部分是物理磁盘上共享表空间中连续的128个页，即2个区，大小同样为2MB。
在对缓冲池的脏页进行刷新时，并不是直接写磁盘，而是通过memcpy函数将脏页先复制到内存的double write buffer,之后通过double write buffer再分2次，每次1MB
顺序地写入共享表空间的物理磁盘中，然后马上调用fsync函数，同步磁盘，避免缓冲写带来的问题。

3. 自适应哈希索引  
InnoDB存储引擎会监控对表上个索引页的查询，如果观察到建立哈希索引可以带来速度提升，则建立哈希索引，称之为自适应哈希索引(AHI)。AHI
是通过缓冲池的B+数页来构造而成的，，因此建立的速度很快，而且不需要对整张表构建哈希索引。InnoDB存储引擎会自动根据访问的频率和模式来自动地为
某些热点页建立哈希索引。    
AHI有一个要求，即对这个也的连续访问模式必须是一样的。例如联合索引(a，b)，访问模式为   
where a = xxx
where a = xxx and b = xxx   

    访问模式一样指的是查询的条件一样，若交替进行上述2种查询，那么不会构建AHI。此外AHI还有如下要求：  
    1、以该模式访问100次    
    2、页通过该模式访问了N次，其中N=页中记录*1/16
    
    可通过innodb_adaptive_hash_index来考虑禁用或者启动该特性，默认是开启的。

4. 异步IO 
为了提高磁盘操作性能，当前的数据库系统都采用异步IO（AIO）来处理磁盘操作。可通过innodb_use_native_aio来控制是否启用native AIO，在Linux默认是on。

5. 刷新领接页
当刷新一个脏页时，InnoDB存储引擎会检测该页所在区的所有页，如果是脏页，那么一起进行刷新。可通过innodb_flush_neighbors来控制，机械硬盘建议启动该特性，固态硬盘建议关闭。


##### 日志文件
~~~
可定位错误日志文件
mysql> show variables like 'log_error'

#显示日志文件的最新50行数据
tail -n 50 log_error.log
~~~

~~~
通过设置log_slow_queries来开启慢查询日志

查询慢查询sql写入日志文件设置的时间，
mysql> show variables like 'long_query_time'

log_queries_not_using_indexes,如果运行的SQL语句没有使用索引，则MySQL数据库同样会将这条SQL语句记录到慢查询日志文件。
5.6.5  版本开始新增一个参数log_throttle_queries_not_using_indexes。用来表示每分钟允许记录到slow.log的且为使用索引的sql次数，默认为0.                 

执行时间最长的10条sql语句
mysqldumpslow -s al -n 10 slow_log.log
~~~



#### 1.3 MyISAM存储引擎
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MyISAM存储引擎不支持事务、表锁设计、支持全文索引，主要面向以下OLAP数据库应用。特点是缓冲池只缓冲索引文件，而不
缓冲数据文件。

~~~
通过SHOW ENGINES语句查看当前使用的MySQL数据库所支持的存储引擎，


mysql -h127.0.0.1 -u root -p
~~~



<h5 id="2">InnoDB存储引擎</h5>
<h5 id="3">文件</h5>
<h5 id="4">表</h5>
<h5 id="5">索引与算法</h5>
<h5 id="6">锁</h5>
<h5 id="7">事务</h5>
<h5 id="8">备份和恢复</h5>
<h5 id="9">性能调优</h5>
<h5 id="10">InnDB存储引擎源代码的编译和调试</h5>